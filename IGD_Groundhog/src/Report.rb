module IGD
	module Groundhog
		module Report

			@format = {
				:units => "mm",
				:size => "letter", #letter is 215.9 by 279.4 mm
				:left_margin => 25,
				:right_margin => 25,
				:top_margin => 25,
				:bottom_margin => 25
			}

			@styles = {
				"main_title" => {:font_size => 22, :color => [0,0,0], :font_type => "bold", :left => "center", :font => 'helvetica'},
				"sub_title" => {:font_size => 18, :color => [0,0,0], :font_type => "normal", :left => "center", :font => 'helvetica'},
				"cover_info" => {:font_size => 18, :color => [0,0,0], :font_type => "normal", :left => "center", :font => 'helvetica'},
				"section_title" => {:font_size => 18, :color => [0,0,0], :font_type => "normal", :left => "center", :font => 'helvetica'},
				"title_1" => {:font_size => 18, :color => [0,0,0], :font_type => "bold", :left => "center", :font => 'helvetica'},
				"title_2" => {:font_size => 16, :color => [0,0,0], :font_type => "bold", :left => 0.0, :font => 'helvetica'},
				"normal" => {:font_size => 12, :color => [0,0,0], :font_type => "normal", :left => 0.0, :font => 'helvetica'},
				"disclaimer" => {:font_size => 12, :color => [0,0,0], :font_type => "normal", :left => "center", :font => 'helvetica'},
			}

			@disclaimer="This report was automatically generated by using Groundhog v#{Sketchup.extensions["Groundhog"].version} (www.groundhogproject.org), which is distributed in the hope that it will be useful, but without any warranty; without even the implied warranty of merchantability or fitness for a particular purpose. See the GNU General Public License for more details.\\n\\nThe accuracy of the results may be highly affected both by the modelling decisions and the parameters used during the simulation. Accordingly, if you have any concern about accuracy, please ask the author of this report.\\n\\nGroundhog was used under SketchUp #{Sketchup.version}"

			@position=0.0 #this keeps track of the vertical position of the line we write on the report

			# Returns a script that is used to write and save a PDF report using jsPDF
			# @author German Molina
			# @return [String] The javascript script
			def self.write_report
				ret="var doc = new jsPDF('portrait','#{@format[:units]}','#{@format[:size]}');"
				ret+="doc.setProperties({subject: 'Groundhog v#{Sketchup.extensions["Groundhog"].version} automatic report',author: 'Groundhog (www.groundhogproject.org)',creator: 'Groundhog (www.groundhogproject.org)'});"

				# Cover
				@position = 10.0
				ret+= self.write_text("main_title","Lighting Analysis Report")
				@position += 12
				ret+= self.write_text("sub_title","Proyect Name")
				@position += 30
				ret+= self.write_text("cover_info","#{Time.now}")
				@position += 30
				ret+= self.write_text("cover_info","Author of report")
				@position += 20
				ret+= self.write_text("cover_info","Company")
				@position += 10

				#Disclaimer
				ret+= self.next_page
				ret+= self.write_text("title_1","Disclaimer")
				@position+= 12
				ret+= self.write_text("title_1","#{@disclaimer}")

				#Daylighting analsys
				ret+= self.write_text("section_title","Disclaimer")
				ret+= self.next_page

				#Planes daylight
				ret+= self.write_text("section_title","Plane 1")
				ret+= self.next_page


				ret += "doc.save('GH_AutoReport.pdf');"
				return ret
			end


			# Returns a javascript that is used to write some text with a certain format
			#
			# If the text is long, it will be split on several lines.
			#
			# @author German Molina
			# @param style [String] The style which we are writing
			# @param text [String] The text to write
			# @return [String] The javascript script
			def self.write_text(style,text)
				properties=@styles[style]
				ret =  "doc.setFont('#{properties[:font]}');"
				ret += "doc.setFontType('#{properties[:font_type]}');"
				ret += "doc.setFontSize(#{properties[:font_size]});"

				page_width = 215.9-@format[:left_margin]-@format[:right_margin]
				width=page_width
				width = page_width - properties[:left] if properties[:left].is_a? Numeric

				ret+= "var text = doc.splitTextToSize('#{text}', #{width});"
				ret+= "doc.text(15, #{@position}, text);"


				return ret
			end

			def self.next_page
				@position=0.0
				"doc.addPage();"
			end

			# Opens the report wizard
			# @author German Molina
			def self.show_report_wizard
				wd=UI::WebDialog.new(
					"Report wizard", false, "",
					595, 490, 100, 100, false )

				wd.set_file("#{OS.main_groundhog_path}/src/html/report.html" )

				wd.add_action_callback("on_load") do |web_dialog,msg|
					metrics = self.get_metrics_list
					script = ""
					script += self.refresh_metrics(metrics)
					script += self.refresh_table(metrics[0])
					web_dialog.execute_script(script)
				end

				wd.add_action_callback("select_metric") do |web_dialog,msg|
					metric = web_dialog.get_element_value("metrics")
					script = ""
					script += self.refresh_table(metric)
					web_dialog.execute_script(script)
				end

				wd.add_action_callback("write_report") do |web_dialog,msg|
					web_dialog.execute_script(self.write_report)
				end

				wd.show()
			end

			# Returns a script that needs to be run to update the metrics input box
			# @author German Molina
			# @param metrics [Array<String>] An array of strings with the entities
			# @return [String] The javascript script that needs to be run to update the metrics input box
			def self.refresh_metrics(metrics)
				script = "var select = document.getElementById('metrics');"
				metrics.each do |metric|
					value = metric
					script += "var option =  document.createElement('option');"
					script += "option.value = '#{value}';"
					script += "option.text = '#{metric}';"
					script += "select.add(option);"
				end
				return script
			end


			# Returns a script that needs to be run to update the metric results table
			# @author German Molina
			# @return [String] The javascript script that needs to be run to update the metric results table
			def self.refresh_table(metric)
				#get all workplanes
				workplanes = self.get_workplane_list
				scale=Results.get_scale_from_model(metric)
				Utilities.remark_solved_workplanes(metric)
				#select those with the corresponding metric
				workplanes = workplanes.select{|x| JSON.parse(Labeler.get_value(x))["metric"] == metric}
				#get the script
				script=""
				script += "var table = document.getElementById('results');"
				script += "table.innerHTML = '<tr><td></td><td>Average</td><td>Minimum</td><td>Maximum</td><td>Min / Average</td><td>Min / Max</td></tr>';"
				workplanes.each do |workplane|
					data = JSON.parse(Labeler.get_value(workplane))

					script += "var row = table.insertRow(-1);"
					#name
					script += "var cell = row.insertCell(0);"
					script += "cell.innerHTML='#{data["workplane"]}';"
					#Average
					script += "cell = row.insertCell(1);"
					script += "cell.innerHTML='#{data["average"].round(1)}';"
					#Minimum
					script += "cell = row.insertCell(2);"
					script += "cell.innerHTML='#{data["min"].round(1)}';"
					#Maximum
					script += "cell = row.insertCell(3);"
					script += "cell.innerHTML='#{data["max"].round(1)}';"
					#Min/Average
					script += "cell = row.insertCell(4);"
					script += "cell.innerHTML='#{data["min_over_average"].round(3)}';"
					#Min/Max
					script += "cell = row.insertCell(5);"
					script += "cell.innerHTML='#{data["min_over_max"].round(3)}';"
				end
				#update scale
				script += "document.getElementById('scale_min').innerHTML='#{scale[0.round(0)]}';"
				script += "document.getElementById('scale_max').innerHTML='#{scale[1].round(0)}';"
				return script
			end


      # Returns an array with the names of the workplanes, obtained from the Solved Workplanes
      # @author German Molina
      # @return [Array <String>] An array with the names of the workplanes
      def self.get_workplane_name_list
        Utilities.get_solved_workplanes(Sketchup.active_model.entities).map{|x| JSON.parse(Labeler.get_value(x))["workplane"]}.uniq
      end

			# Returns an array with the solved workplanes in the model
			# @author German Molina
			# @return [Array <String>] An array with the names of the workplanes
			def self.get_workplane_list
				Utilities.get_solved_workplanes(Sketchup.active_model.entities)
			end

      # Returns an array with the names of the metrics within the solved-workplanes, obtained from the Solved Workplanes
      # @author German Molina
      # @return [Array <String>] An array with the names of the metrics
      def self.get_metrics_list
        Utilities.get_solved_workplanes(Sketchup.active_model.entities).map{|x| JSON.parse(Labeler.get_value(x))["metric"]}.uniq
      end



      # Exports a CSV with the values and statistics of a solved workplane
      # @author German Molina
      # @param group [Solved Workplane] A Solved Workplane that will be exported
      def self.report_csv(group)
        if not Labeler.solved_workplane? group then
          UI.messagebox "ERROR: Attempted to report a CSV file from a group that is not a Solved Workplane"
          return
        end

        begin
          op_name = "Export workplane to CSV"


          path=Exporter.getpath #it returns false if not successful
          path="" if not path

          value=JSON.parse(Labeler.get_value(group))
          filename="#{Utilities.fix_name(value["workplane"])}_#{Utilities.fix_name(value["metric"])}.csv"
          filename=UI.savepanel("Export CSV file of results",path,filename)

          if filename then
            File.open(filename,'w'){|csv|
              statistics = Results.get_workplane_statistics(group)
              #write statistics
              statistics.to_a.each{|element|
                csv.puts "#{element[0]},#{element[1]}"
              }
              #Write header
              csv.puts "Position X, Position Y, Position Z, Value (depends on the metric)"
              #Write pixels
              pixels = group.entities.select{|x| Labeler.result_pixel?(x)}
              pixels.each do |pixel|
                vertices=pixel.vertices
                nvertices=vertices.length
                center=vertices.shift.position.to_a
                vertices.each{|vert|
                  pos=vert.position.to_a
                  center[0]+=pos[0]
                  center[1]+=pos[1]
                  center[2]+=pos[2]
                }
                csv.puts "#{(center[0]/nvertices).to_m},#{(center[1]/nvertices).to_m},#{(center[2]/nvertices).to_m},#{Labeler.get_value(pixel)}"
              end
            }
          end


        rescue => e
          model.abort_operation
          OS.failed_operation_message(op_name)
        end
      end




    end # end REPORT module
  end # end Groundhog
end #end IGD
